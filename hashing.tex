In questa sezione vedremo le funzioni hash, delle funzioni che permettono di mappare degli elementi di un universo in uno degli elementi di un insieme finito. 
Una funzione hash è una funzione $h: U \to [0,n)$, informalmente $h$ è utilizzata per ``randomizzare'' i dati:
\begin{enumerate}
    \item $h(x)$ dovrebbe essere più casuale possibile. Idealmente dovrebbe mappare in modo più uniforme possibile
    \item $h(x)$ dovrebbe essere veloce da calcolare. Idealmente proporzionale al tempo di accesso a $x$
    \item $h$ dovrebbe occupare poco spazio in memoria. Idealmente $O(1)$ parole di memoria
\end{enumerate}
\begin{definition}[Famiglia di funzioni hash]
    Una famiglia di funzioni hash $\mathcal{H}$ è un sottoinsieme di funzioni $h: U \to [0,n) $, nell'inieme di tutte le funzioni hash $\mathcal{H} \subseteq [0,n)^{U}$.
\end{definition}
\vspace{0.5em}
\begin{definition}[Funzione hash uniforme]
    Una funzione hash $h$ da un universo $U = \{x_0,\dots,x_u\}\ (u = |U|)$ . $\mathcal{H}$ è detta uniforme se per ogni $y_1,\dots,y_u \in [0,n)$ si ha che
    \[
        \Pr\left[h(x_1),\dots,h(h_u) = y_1,\dots,y_u\right] = \frac{1}{n^u}
    \]
\end{definition}
\begin{definition}
    Una famiglia $\mathcal{H}$ è detta \emph{k-indipendente} se e solo se per una scelta uniforme di $h \in \mathcal{H}$ si ha 
    \begin{enumerate}
        \item Per ogni $x \in U$, $h(x)$ è una variabile aleatoria uniforme in $[0,n)$
        \item Le variabili aleatorie $h(1),h(2),\dots,h(u)$ sono \emph{k-indipendenti}
    \end{enumerate}
    o in modo equivalente
    \[
        \Pr\left[\bigcap_{i=1}^{k}h(x_i) = y_i\right] = \frac{1}{n^k}
    \]
    per ogni scelta di $x_1,\dots,x_k \in [1,u]$ $y_1,\dots,y_k \in [0,n)$. O anche la \emph{k-tupla} $(h(x_1),\dots, h(x_k))$ è uniforme in $[0,n)^k$. Per $k=n$ la famiglia di funzioni hash è detta completamente uniforme.
\end{definition}

\subsection{Hashing universale}
\begin{center}
    \emph{Nota Bene: In questi appunti, $n$ è definito come il numero di slot di arrivo della funzione hash.}
\end{center}
Una famiglia di funzioni hash $\mathcal{H}$ è detta universale se scegliendo $h \in_u \mathcal{H} \ \ h: U \to [0,n)$ dati $\forall x_1 \neq x_2 \in U$
\[
    \Pr[h(x_1) = h(x_2)] \leq \frac{1}{n}
\]in pratica la probabilità di collisione di due elementi di $U$.
Si nota che questa probabilità è quella che ci si aspetta per una funzione hash che dia un risultato \emph{veramente} totalmente casuale

\begin{theorem}[2-indipendenza implica universalità]
    \begin{align*}
        \Pr[h(x_1) = h(x_2)] &= \sum_{y \in U} \Pr[h(x_1) = h(x_2) \land h(x_2) = y]\\
        &= \sum_{y \in U} \Pr[h(x_1) = y \land h(x_2) = y]\\
        &= \sum_{y \in U} \frac{1}{n^2} = \frac{1}{n}
    \end{align*}
\end{theorem}
\begin{theorem}
    Sia  $\mathcal{H}$ una famiglia di funzioni hash universali, $S \subseteq U$ un insieme di $k$ elementi. Sia $u \in S$. Si sceglie in modo uniforme una funzione $h$ da $\mathcal{H}$, e sia $X$ la variabile aleatoria che conta il numero di elementi di $S$ mappati nello stesso elemento $h(u)$ allora
    \[
        \E{X} \leq 1 + \frac{k}{n}.
    \]
\end{theorem}
\begin{proof}
    Sia $u$ fissato, per ogni $s \in S$, si definisce la variabile aleatoria $X_s$ associata
    \[
        X_s = \begin{cases*}
            1 \text{ se } h(s) = h(u)\\
            0 \text{ altrimenti}
        \end{cases*} 
        \quad X = \sum_{s \in S}X_s
    \]
    Per cui si ha
    \begin{align*}
        &\E{X} = \sum_{s \in S}{\E{X_s}} = \sum_{s \in S}\Pr[h(s) = h(u)]\\
        &= 1 + \sum_{s \in S-\{u\}}\Pr[h(s) = h(u)]\\
        \substack{\text{(Per universalità)}} &\leq 1 + \frac{k}{n}.
    \end{align*}
    \emph{Nota: per $m = \Theta(m)$ si ha $O(1)$ tempo per operazione.}
\end{proof}

Si passa ora alla definizione di una famiglia di funzioni hash universale
\subsection{Esempi famiglie hash universali}
\subsubsection{Esempio 1}
Si sceglie un numero primo $m > n$, è noto che esiste $m$ tale che $\forall n \ n \leq m \leq 2n$, successivamente si identifica ogni elemento $x \in U$ come un intero in \emph{base m}, di $r$ cifre $x = (x_1,x_2,\dots,x_r)$. Per una $a = (a_1,a_2,\dots,a_n) \in U, a_i \in [m]$ fissata si definisce
\begin{align}
    h_a(x) = \left[ \sum_{i=1}^{r}a_ix_i\right] \mod m
\end{align}
Per cui si definisce la famiglia di funzioni hash universale $\bar{\mathcal{H}}$
\[
 \bar{\mathcal{H}} = \{ h_a : a \in U\}
\]
Per $|U| = n$, $r$ deve essere $\log_m(n)$ poiché $m^r \geq n$. Ne risulta che per scegliere una funzione hash in modo uniforme $h \in_u \bar{\mathcal{H}}$ è sufficiente scegliere $a \in_u U$.

\begin{theorem}[Universalità]
    La famiglia $\bar{\mathcal{H}}$ è una famiglia universale
\end{theorem}

\begin{proof}
    Sia $x = (x_1,x_2\dots,x_r)$ e $y = (y_1,y_2\dots,y_r)$ $\in U$ tale che $x \neq y$. 
    
    Si deve dimostrare $\Pr[h(x) = h(y)] \leq \frac{1}{n}$ (universalità).
    \vspace{1em}
    Poiché $x\neq y$ esiste $y$ t.c. $x_j \neq y_j$.
    $h_a(x) = h_a(y)$ se e solo se
    \[
        a_j\underbrace{(y_j-x_j)}_z = \underbrace{\sum_{i\neq j}a_i(x_i - y_i)}_\alpha \mod m
    \]
    Si assume $a \in_u U$, quindi si assume $a_i$ fissato $\forall i \neq j$. Per $m$ primo $\mathbb{Z}_m$ è un campo, per cui, per $z \neq 0$ esiste un'unica inversa moltiplicativa $z^{-1}$ tale che $z \cdot z^{-1} = 1 \mod m$

    \begin{align*}
        a_j \cdot z \cdot z^{-1} &= \alpha \cdot z^{-1} \mod m\\
        a_j &= \alpha \cdot z^{-1} \mod m \substack{\text{ (soluzione unica)}} \\
        &\Pr[a_j \equiv_m \alpha z^{-1}] \leq \frac{1}{m}.
    \end{align*}
\end{proof}

\subsubsection{Esempio 2}
Si mostra ora una famiglia  di funzioni hash \emph{2-indipendenti} sia $p \geq n$ un numero primo, siano $a,b \in \mathbb{Z}_p$ definite come nell'esempio precedente, si definisce la funzione hash $h_{a,b}$
\[
    h_{a,b}(x) = \left[ax + b \mod p\right] \mod m
\]
in pratica la funzione hash è definita come un polinomio scelto uniformemente in $\mathbb{Z}_p$ di grado 1. Si definisce la famiglia $\hat{\mathcal{H}}$
\[
    \hat{\mathcal{H}} = \{ h_{a,b} \mid a,b \in \mathbb{Z}_p\}
\] 
\begin{theorem}[2-indipendenza e universalità]
    $\hat{\mathcal{H}}$ è una famiglia \emph{2-indipendente} e universale
\end{theorem}
\begin{proof}
    Sia $X = (ax + b) \mod p$ e $Y = (ay +b) \mod p$ per $x \neq y$. Poiché $a \neq 0$ e $p > n$ allora $X \neq Y$.
    \[
        h_{a,b}(x) = h_{a,b}(y) \iff X = Y \mod m
    \]
    \begin{enumerate}
        \item $X$ e $Y$ sono distribuite in modo uniforme su $\mathbb{Z}_p$, poiché $a,b$ sono, a loro volta, distribuite in modo uniforme e $h$ è lineare iniettiva.
        \begin{proof}
            \begin{align}
                    ax + b \equiv_p ay + b
                &\iff
                    a(x-y) \equiv_p 0
                \\
                \implies (x-y) \equiv_p 0
                &\iff x = y
            \end{align}
        Il passaggio (6) è giustificato poiché $ x,y < p-1$
        \end{proof}
        
        \item $X$ e $Y$ sono quasi indipendenti tra loro, $\Pr[X = i \land Y = j] = \frac{1}{(p-1)p}$
        \begin{proof}
            \begin{equation}
                \begin{cases*}
                    ax + b \equiv_p i\\
                    ay + b \equiv_p j\\
                \end{cases*}
            \end{equation}
            Esiste un unica soluzione per $(a,b) \in {\mathbb{Z}_p}^2$, poiché il rango è 2.
            Siano $f,g$ soluzioni uniche del sistema lineare 
            \begin{align*}    
                \Pr\left[ (ax + b) \equiv_p i \land (ay + b) \equiv_p j\right] &= Pr[a = f(x,y,i,j) \land b = g(x,y,i,j) ]\\
                &= \Pr[a = f(x,y,i,j)] \cdot \Pr[b = g(x,y,i,j)]
            \end{align*}
            Per cui
            \begin{align*}    
                \Pr\left[ Y = j\mid X = i\right] &= \frac{\Pr[X = i \land Y = j]}{\Pr[X = i]}\\
                &= \frac{1}{p-1}
            \end{align*}    
        \end{proof}    
    \end{enumerate}
    Per una $i$ fissata in $\mathbb{Z}_p$ ci sono al massimo $\frac{p}{m}-1 \leq \frac{(p-1)}{m}$ valori per $Y$ tale che $Y = i \mod m$, ovvero tutti gli interi $\in \mathbb{Z}_p$ per cui la distanza da $i$ è un multiplo di $m$. Da 2 $\Pr[Y = j \mid X = i] = \frac{1}{p-1}$ per l'union bound si ottiene $\Pr[Y=i \mod m \mid X = i] \leq \frac{p-1}{m} \frac{1}{p-1} = \frac{1}{m}$. $\hat{\mathcal{H}}$ è universale.
\end{proof}

\subsection{Perfect hashing}
Parliamo ora di funzioni hash \emph{perfette} ovvero una funzione hash senza collisioni
\begin{definition}[funzione hash perfetta]
    Una funzione hash $h: [1,n] \to [0,M]$ è detta perfetta su un insieme $A \subseteq [1,n]$ se e solo se per ogni $x_1 \neq x_2 \in A$ si ha $h(x_1) \neq h(x_2)$, quindi è iniettiva su $A$. In generale cerchiamo una funzione che abbia tale proprietà con alta probabilità.
\end{definition}
\begin{theorem}
    Se una famiglia $\mathcal{H}$ di funzioni $h: [1,n] \to [0,M)$ è universale e $M \geq n^{c+2}$ per una costante $c$ arbitrariamente grande allora $h \in_u \mathcal{H}$ è perfetta su ogni insieme $A \leq [1,n]$ con alta probabilità.
\end{theorem}
\begin{proof}
    Universalità significa che $\Pr[h(x_1) = h(x_2)] \leq \frac{1}{M}$ per $x_1 \neq x_2$, ci sono al massimo $|A|^2 \leq n^2$ coppie di elementi distinti in $A$, dallo union bound la probabilità di avere almeno una collisione è al massimo $\frac{n^2}{M}$, scegliendo $M = n^{c+2}$ si ha una collisione con probabilità $\leq n^{-c}$, ovvero la funzione è perfetta con alta probabilità $(1-n^{-c}$).
\end{proof}

Il problema del dizionario è spesso presentato come l'esempio pratico per mostrare l'efficacia delle funzioni hash
\subsection{Il problema del dizionario}
Il dizionario è un tipo di dati, dato un universo $U$ di elementi possibili, mantiene un sottoinsieme arbitrario $S \subseteq U$ tale che operazioni come intersezione, unione, e ricerca in $S$ siano efficienti, queste operazioni sono rappresentate come:
\begin{itemize}
    \item \texttt{create()} inizializza un dizionario vuoto
    \item \texttt{insert(u)} aggiunge un elemento $u \in U$ a $S$
    \item \texttt{delete(u)} rimuove un elemento $u$ da $S$
    \item \texttt{lookup(u)} risponde alla domanda $s \in S?$
\end{itemize}

La sfida principale riguarda la grandezza dell'universo $U$ che può essere estremamente grande, per cui definire un array di dimensione $|U|$ non è ragionevole, si cerca una soluzione proporzionale al sottoinsieme $n := |S|$.
Una soluzione deterministica è implementata con gli alberi \emph{AVL} con $O(n)$ spazio e $O(\log n)$ tempo per operazione.

\vspace{1em}
Si presenta una soluzione probabilistica con $O(n)$ spazio e $O(1)$ tempo atteso per operazione, a tale scopo si presenta il concetto di tabelle hash.
\subsubsection{Tabelle hash}
Viene creato un array $H$ di grandezza $m \approx n$, quindi $H = [m]$. Si ha una collisione quando $h(u) = h(v)$ per u $\neq v$, mediamente per il paradosso del compleanno una collisione è attesa ogni $\sqrt{n}$ inserimenti.

Per ogni posizione $i$ dell'array $H[i]$ contiene delle \emph{linked list} che contengono tutti gli elementi che collidono, solitamente chiamate \emph{liste di trabocco}.

\input{figure/hash_table.tex}

Le operazioni sono implementate come segue, 
viene calcolato il valore di $h(u)$, successivamente l'operazione viene eseguita scandendo $H(h(u))$.
È quindi necessario utilizzare una funzione hash $h$ che distribuisca gli elementi di $S$ in modo uniforme

\vspace{1em}\noindent
È possibile utilizzare la tecnica dell' \emph{hashing deterministico}, in cui ogni elemento $u \in U$ è rappresentato come intero, scegliendo un primo $p$, tale che $m \leq p \leq 2m$ allora $h$ è definito come 
\[
    h(u) = u \mod p
\]
funziona bene per applicazioni statiche in cui $S$ non varia.

\vspace{1em}
Per applicazioni in cui $S$ varia si fa uso delle funzioni hash universali, di cui sono state precedentemente descritte le proprietà ed esempi.
Si ricordando le variabili $n$ rappresentate il numero di elementi di $S$, $N = |U|$, $m$ numero primo compreso $N \leq m \leq 2N$. Si fa uso della tecnica di \emph{doubling-halving}

\input{algorithms/doubling_halving.tex}
Si ottiene tempo $O(1)$ ammortizzato per eliminazione e inserimento, poiché il re-hashing avviene solo quando la dimensione raddoppia.

%TODO: Fare perfect hashing